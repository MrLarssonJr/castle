use std::str::FromStr;
use std::rc::Rc;

use crate::ast::*;

grammar;

pub Expression: Expression = {
    BooleanExpression
};

// ################################
// BOOLEAN
// ################################

BooleanExpression: Expression = {
    Disjunct,
    <l:Disjunct> <tail:("||" Disjunct)+> => Expression::binary_operation(l, tail),
};

Disjunct: Expression = {
    Conjunct,
    <l:Conjunct> <tail:("&&" Conjunct)+> => Expression::binary_operation(l, tail),
};

Conjunct: Expression = {
    Negand,
    <negations:("!")+> <operand:Negand> => Expression::unary(negations, operand),
};

Negand: Expression = {
    BooleanLiteral,
    ComparisionExpression,
};

// A literal that produces a number
BooleanLiteral: Expression = {
    "true" => Expression::BooleanLiteral(BooleanLiteralExpression(true)),
    "false" => Expression::BooleanLiteral(BooleanLiteralExpression(false)),
};

// ################################
// Comparision
// ################################

ComparisionExpression: Expression = {
    NumberExpression,
    <l:NumberExpression> "<" <r:NumberExpression> => Expression::binary_operation(l, vec![("<", r)]),
    <l:NumberExpression> "<=" <r:NumberExpression> => Expression::binary_operation(l, vec![("<=", r)]),
    <l:NumberExpression> "==" <r:NumberExpression> => Expression::binary_operation(l, vec![("==", r)]),
    <l:NumberExpression> "!=" <r:NumberExpression> => Expression::binary_operation(l, vec![("!=", r)]),
    <l:NumberExpression> ">=" <r:NumberExpression> => Expression::binary_operation(l, vec![(">=", r)]),
    <l:NumberExpression> ">" <r:NumberExpression> => Expression::binary_operation(l, vec![(">", r)]),
};

// ################################
// NUMBER
// ################################

NumberExpression: Expression = {
    Term,
    <l:Term> <tail:("+" Term)+> => Expression::binary_operation(l, tail),
    <l:Term> <tail:("-" Term)+> => Expression::binary_operation(l, tail),
};

Term: Expression = {
    Factor,
    <l:Factor> <tail:("*" Factor)+> => Expression::binary_operation(l, tail),
    <l:Factor> <tail:("/" Factor)+> => Expression::binary_operation(l, tail),
};

Factor: Expression = {
    Operand,
    <negations:("-")+> <operand:Operand> => Expression::unary(negations, operand)
};

Operand: Expression = {
    BaseAtom,
    NumberLiteral,
};

// A literal that produces a number
NumberLiteral: Expression = r"[0-9]+" => Expression::NumberLiteral(NumberLiteralExpression(isize::from_str(<>).unwrap()));


// ################################
// OTHER
// ################################

BaseAtom: Expression = {
    FunctionApplication,
    FunctionLiteral,
    LetIn,
    IfElse,
    Identifier => Expression::Identifier(IdentifierExpression(<>)),
};

// A literal that produces a function
FunctionLiteral: Expression = "fn" "(" <parameters:Comma<Identifier>?> ")" "{" <body:Expression> "}" => match parameters {
    Some(parameters) => {
        let parameters: Vec<Identifier> = parameters;
        Expression::FunctionDefinition(FunctionDefinitionExpression {
            parameters,
            body: Rc::new(body),
        })
    },
    None => Expression::FunctionDefinition(FunctionDefinitionExpression {
        parameters: Vec::new(),
        body: Rc::new(body),
    }),
};

IfElse: Expression = "if" <condition:BooleanExpression> "{" <then_branch:Expression> "}" "else" "{" <else_branch:Expression> "}" => Expression::IfElse(IfElseExpression {
    condition: Rc::new(condition),
    then_branch: Rc::new(then_branch),
    else_branch: Rc::new(else_branch),
});

LetIn: Expression = "let" <binding:Identifier> "=" <value:Expression> "in" <body:Expression> ";" => Expression::LetIn(LetInExpression { binding, value: Rc::new(value), body: Rc::new(body) });

FunctionApplication: Expression = <function:BaseAtom> "(" <arguments:Comma<Expression>?> ")" => Expression::FunctionApplication(FunctionApplicationExpression {
    function: Rc::new(function),
    arguments: arguments.unwrap_or_else(|| Vec::new()),
});

Comma<T>: Vec<T> = <head:T> <mut tail:("," <T>)*> => {
    tail.insert(0, head);
    tail
};

Identifier: Identifier = r"[a-zA-Z_-]+" => Identifier(String::from(<>));
